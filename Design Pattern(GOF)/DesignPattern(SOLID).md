# Design Pattern
>> 코드를 더 알아보기 쉽게 혹은 짜기 쉽게, 유지보수가 쉽게 하기 위해 설계 단게에서 사용되는 기술이다.

* 디자인 패턴을 배우고 나면, 코딩을 쉽게하기 위해 디자인 패턴을 활용하는 것이 아니라, 디자인 패턴을 적용시키기 위해 코딩을 하는 경우가 있다.
* 디자인 패턴을 배우는 이유가 코딩을 쉽게하는데 있는 만큼, 코딩을 할 때, 무조건 디자인 패턴을 적용시키기는게 아니라, 내가 설계할 때 사용할 수 있는 도구가 늘어났다는 관점으로 가야한다.
* 즉, 디자인 패턴을 적용시키지 않아도 혹은 적용시키면 안되는 프로그래밍은 디자인 패턴을 적용시키지 않는 것이 맞다는 소리다.

***
# SOLID
***
## Single Responsibility principles(단일 책임 원칙)
>> 하나의 객체는 하나의 책임을 갖는다
* 쉽게말해 객체의 이름에 맞는 역할만을 수행할 것을 요구한다는 것이다.

### Single Responsibility을 따르지 않는다면?
* 1객체=1책임의 원칙을 깬다면, 하나의 객체에 많은 기능을 수행하게 해야한다.
* 그렇게되면, 한 객체에 의존성이 높아지게된다.
* 의존성이 높아지면, 다른 객체에서 이 객체에 연관성이 높아져 많은 기능과 변수를 public으로 열어줘야한다.
* 그러면, 객체지향의 특성인 은닉화와 캡슐화에 위배되는 설계이다.

### Single Responsibility 적용하려면?
* 간단히 1객체=1책임을 따르면 된다.
* 예를 들어, 컴퓨터라는 객체가 있다고 하자
* 그러면 컴퓨터라는 상위 클래스를 만들고, cpu, memory, cache, disk.... 등의 하위클래스를 만들면 된다.
* 이렇게 되면, 컴퓨터라는 객체에 의존성이 감소한다. 이는 객체지향 설계에 가까워지는 것이다.
* 만약 ram의 기능을 수정하고 싶으면, ram class만 수정하고, cache의 기능을 수정하고 싶으면 cache class를 수정하면 되기 때문에, 한 객체에 많은 책임을 지게하지 않는다.
* 즉, 한 객체가 가지는 책임을 다른 객체에 분산하거나, 그 객체에 맞는 책임만을 주어야한다는 것이다.

### 핵심
>> 한 객체에 하나의 책임만을 부여 함으로써 객체끼리 의존성을 떨어뜨리고 유지보수하기 쉬워진다.

***
## Open Closed principles(개방 폐쇄 원칙)
>> 확장은 개방적으로, 수정은 폐쇄적으로 설계해야한다는 원칙이다.
* 하나의 기능을 두고, 확장할 때, 기능을 수정하는 것이 아니라 확장의 대상만 추가하는 것이다.

### Open Closed principles을 따르지 않는다면?
* 예를 들어, Animal이라는 클래스에 기능으로 동물의 울음소리를 내는 함수가 있다고 하자
* 이 함수는 Animal객체의 type이라는 멤버 변수의 값에 따라 울음소리를 다르게 낸다
* 함수 내부적으로는 if문으로 type이 cat이면 meow를 dog이면 bark를 출력하도록 설계되어있다.
* 이때, type이 cow인 경우를 추가하고 싶을 때, 함수를 반드시 수정해야한다.
* 지금의 예시는 하나의 기능만을 서술하고 있어 함수를 수정한다는게 적은 노동값을 가진다고 생각할 수 있다.
* 하지만, 기능을 가지는 함수가 1개가 아니라, 20개가 넘는 함수가 있다면, type이 cow를 추가할 때, 이 모든 함수를 type이 cow일때의 경우를 생각해서 수정해주어야한다.

### Open Closed principles를 적용하면?
* Animal클래스를 상위클래스로 구분하고 하위 클래스로 Cat과 Dog을 만든다.
* 울음소리를 내는 함수 hey를 Animal에 구현한다.
* 그리고 Cat과 Dog에 hey를 각 동물의 울음소리에 맞게 오버라이딩한다
* 이 때, hey를 호출하면 호출한 객체의 타입에 따라 울음소리가 나온다
* 여기서 cow를 추가하려면 hey의 기능을 고치는 것이 아닌, Cow라는 class만 정의 해주면 hey함수의 수정 없이 기능을 확장할 수 있다.
* 이 경우 cow를 추가하는 것을 open hey함수를 수정하지 않는 것이 closedd이다.

### 핵심
>> 새로운 객체에 대응하는 기능을 확장함에 있어 객체만 확장하면 기능을 수정할 필요없이 원하는 동작을 할 수 있다는 것이다.

***
### Liskov Substitution principle(리스코프 치환 법칙)
>> 부모클래스와 자식클래스가 있을 때, 자식클래스가 부모클래스로 치환될 때, 기능을 수행함에 문제가 없어야 한다는 것이다.
* 자식객체가 부모객체로 업캐스팅 되었을 때, 여전히 동작이 잘 되어야한다는 것이다.

### Liskov Substitution principle을 따르지 않는다면?
* 먼저 부모클래스와 자식클래스의 정의가 명확해야한다. 
* 예를 들어 Animal이라는 부모클래스에 Cat이라는 자식클래스가 있고, Animal클래스에  울음소리를 내는 hey함수가 있다.
* 이때, Fish가 Animal을 상속받는 자식클래스라면, Fish 객체를 Animal객체로 업캐스팅 한다면
* 울음소리가 정의되어 있지 않은 Fish객체는 hey함수를 사용할 수 없다.
* 따라서 자식객체가 부모객체로 완전히 대체되지 않는다면, 동작을 수행하는데 오류가 날 수 있다는 것이다.

### 핵심
>> 자식객체가 부모객체로 완전히 대체가능해야 한다.

***
## Interface segregation Principle(인터페이스 분리 원칙)
 