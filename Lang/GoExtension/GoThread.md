# Thread
일반적으로 CPU는 하나의 프로그램을 명령어 순서대로 실행한다. 즉, 한개의 CPU는 한 개의 프로그램만을 처리할 수 있다는 것이다. 이렇게 되면, 음악을 들을때는 음악만, 게임을 할때는 게임만해야한다. 하지만, 현대의 컴퓨터에서는 음악도 듣고 게임도 하고 웹도 사용할 수 있다.

그럼 이것을 어떻게 가능하게 하는 것일까? 만약 두 개의 프로그램이 있고, CPU 하나로 처리해야한다고 하자. 본래라면, 이것은 불가능하다. 하지만, CPU한개가 두 프로그램을 빠르게 왔다갔다하면서, 사용자 입장에서는 마치 동시에 수행되고 있게 느껴지게 한다면? 이것이 CPU 두개로 두개의 프로그램을 돌리는 것과 같아 보인다. 그리고 이것을 **멀티태스킹**이라고 한다.

자세히 설명하자면, CPU가 두 개의 프로그램을 돌릴 때, 하나의 프로그램을 돌리다가 어느정도 수행하고 마지막 수행지점을 기억한 후, 다른 프로그램으로 가서 다시 일정부분 돌리고 마지막 수행지점을 기억한 후, 원래 프로그램의 마지막 수행지점으로 돌아가 다시 일정부분을 반복하는 과정을 거친다. 이 과정을 **Context Switching**이라고 한다.여기서 Context는 CPU가 다루고 있는 정보를 뜻한다.

하지만, 주의할 점은 처리해야할 프로그램에 비해 너무 적은 CPU가 있어서 Context Switching이 너무 자주 일어나게 된다면 Thread를 전환하는데 쓰이는 비용이 많이 발생하기 때문에 비효율 적이다.

OS에서 멀티태스킹을 위해 효율적으로 Thread를 관리해준다. 즉, 어떻게 관리해야 Context Switching을 최대한 효율적으로 관리하기 위해 Thread를 배분할지 OS에서 관리해준다는 것이다. 이때 OS에서 관리하는 Thread를 Kernel Thread라고 한다.

Go Thread는 OS에서 관리하는 Kernel Thread를 더 잘게 쪼개서 처리할 프로그램에 할당해준다.(NM Thread) 이것이 Go Thread의 큰 장점이다. 이렇게 되면, 프로그래머 입장에서는 어떻게 Kernel Thread를 더 잘게 쪼개서 내 프로그램에 Thread를 배분해주는 것인지는 모른다. 하지만, 그것을 아는 것과 상관없이, 프로그래머가 일단, 병렬연산을 요구하면, 알아서 내부적으로 Go에서 Thread를 할당해준다는 것이다. 이 점이 다른언어와 다른 장점이다.(일반적으로는 Kernel Thread를 직접 관리해야하기 때문에)

### 취약점
한개의 프로그램을 실행하면 OS에서는 하나의 메모리를 할당해준다. 프로그램에서는 여러개의 쓰레드가 연산하고 있는데 메모리는 하나여서 이 메모리를 쓰레드들이 나눠써야한다.

그렇게 되면, 한개의 쓰레드(cpu1)가 메모리의 어떤 값A를 참조하고 있는데, 동시에 다른 쓰레드(cpu2)가 A를 참조한다고 하면, cpu1이 A를 사용하고 새로운 값으로 채워주었는데 cpu2가 A값을 다른 새로운 값으로 넣어주면, cpu1의 연산 값은 사라지고, cpu2의 연산값만 남게된다.

만약 개발자의 의도는 cpu1가 채워준 A를 이용해서 cpu2가 활용해야하는 경우도 문제가 된다. 이것이 멀티태스킹에서 쓰레드의 대표적인 메모리 동기화 문제이다.

#### 해결방법
Mutex라는 방법이 있다. 이 방법은 먼저 cpu1이 A를 참조하면, cpu1의 사용이 끝날 때까지, 잠금을 걸어놓고 다 쓰면, 잠금을 풀어주는 방법이다. 즉, cpu2입장에서는 cpu1이 잠금을 풀어주기 전까지 기다리게 된다.

##### DeadLock
하지만, 이 방법에서는 큰 문제가 있다. DeadLock이다. DeadLock은 병렬 처리 중에 cpu1과 cpu2가 있다면, 각자 할당된 일을 하기위해 cpu1은 A를 잠그고 B를 잠그고 일을 처리하고 A를 풀고 B를 푸는 과정을 cpu2는 B를 잠그고 A를 잠그고 수행 후 B를 풀고 A를 푼는 작업을 한다고 하자.

참고로, 실제로 쓰레드는 cpu가 Context Switching하는 것이기 때문에 실제 동작은 cpu1이 A를 잠그고 B를 잠그려고 했을 때, 이미 Context Switching으로 cpu2가 B를 잠그고 온 상태라면, cpu1은 B를 잠그기 위해 기다리고 있을 것이고, cpu2는 이제 A를 잠굴 차례이기 때문에 기다리고 있을 것이다. 따라서, 두 cpu모두 서로 풀기를 기다리기만 하고 다음일을 수행할 수 없는 상태에 놓인다.

여기에 개발자는 Go Thread가 어떻게 작업을 분배하는지 모르기 때문에 어떤 cpu가 먼저 Lock을 걸고 어디에서 작업을 중단하고 다음 cpu가 잠굴지 모르기 때문에, DeadLock을 방지하는데에 한계가 있다.

이 문제를 해결하기 위해 Go에서는 Channel을 제공하고 있다.


##### 용어 정리
* 프로그램: 여러개의 기능이 모인 하나의 실행파일(=:어플)
* 프로세스: 프로그램 안에 있는 많은 실행파일들 중 하나하나
* 쓰레드: 프로세스를 처리하기 위해 할당되는 연산단위. 프로세스는 즉, 하나 혹은 여러개의 쓰레드를 가질 수 있음.