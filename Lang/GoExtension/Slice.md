# Slice
> 기본으로 할당받은 길이를 가지는 배열이며, 배열을 넘어서는 값이 추가가 되면 길이가 늘어난 새로운 배열에 기존 배열의 값을 복사해서 넣고 새로운 값을 뒤에 붙여서 배열의 길이를 동적으로 늘릴 수 있다.

동적배열은 다른 언어에서도 사용하고 있는 개념이고, C++에는 vector가 있다.
기본적으로 배열은 정해진 크기를 넘어서는 값을 저장할 수 없고, 배열은 선언된 메모리의 첫번째 부분. 즉, 배열의 첫번째 값의 주소로 배열을 참조한다. 이를 정적배열이라 한다.

동적배열은 기존의 크기의 배열의 넘어서는 값이 추가가 되면 1,2,4,8,16... 2배씩 공간을 추가로 할당한 새로운 메모리 공간에서 기존의 배열의 값을 복사해 가져오고 새로운 값을 추가시킨 새로운 메모리 공간의 주소 값을 참조하게 된다.

Go에서 Slice의 선언은 아래와 같다.
```go
var a [] int
a := []int{1,2,3} // 1,2,3이 들어간 길이가 3인 Slice
a := make([]int, 3) // 3만큼의 길이를 확보한 Slice
a := make([]int, 3, 8) // 길이가 3이고 배열의 최대 길이가 8인 Slice
```
길이(Length)와 배열의 최대 길이(Capacity)의 차이점은 length는 현재 Slice에서 사용되는 공간의 길이이고, capacity는 Slice에 할당된(추가 할당없이 쓸 수 있는 공간)을 의미한다. 즉, capacity가 부족해지면, 추가로 공간을 할당한다는 것.

이미 할당된 공간에서는 일반 배열과 같이 index로 접근해서 값을 넣을 수 있다. 반대로 할당되지 않은 공간에서는 append함수로 값을 추가해야한다.

append함수는 앞에 설명한 동적배열의 원리를 따른다. 그렇기 때문에 append함수는 첫번째 인자로 값을 추가할 Slice, 두번째 인자로 추가할 값을 받는다.(여러개를 넣어도 됨) 그리고, slice에 할당된 공간이 남아있어 추가로 할당하지 않아도 된다면, 인자로 받아온 slice의 주소를 반환한다. 만약, 인자로 받아온 slice에 공간이 남아있지 않으면, 추가로 메모리를 할당한 새로운 공간에 기존의 값을 복사하고 두번째 인자로 받아온 새로운 값을 추가한 새로운 slice의 주소를 반환한다.

이렇듯이 slice는 값을 추가할 때, 기존의 slice의 주소를 유지할 것인지 새로운 slice의 주소를 반환받을 것인지 항상 예측하기 힘들다. 이렇게 되면 현재 내가 쓰는 slice가 append함수를 거쳐 내가 처음부터 썼던 주소의 slice인지 새로 생긴 slice의 주소인지 몰라 혼동이 생길 수 있다. 그렇기 때문에 애초에 append함수를 쓰기 전에 애초에 다른 변수에 기존 slice값을 복사하고 append를 받아 slice를 분리해서 관리하는 것이 안전하다.(근데 애초에 하나의 slice에만 append하면 괜찮지 않나?)

Slice가 slice인 이유는 일부를 덜어낼 수 있기 때문이다.
```go
a := []int{1,2,3,4,5}
b := a[1:3] // 1번째 인데스부터 2번째 인덱스까지를 덜어냄

fmt.Println(b) // [2,3]
```
이때 b는 새로운 메모리를 할당하는 것이 아니라, 기존의 slice, a에서 1번째 인덱스의 주소를 가르키고, 길이가 2로 정해진다. 그래서 b는 길이가 2인 a[1]을 주소로 갖는 slice이다. 그렇기 때문에 b의 값들이 바뀌면 a도 같은 메모리를 공유하기 때문에 같이 값이 바뀐다.

Slice는 일종의 구조체이다. property로는 배열의 첫번째 인덱스의 주소값, length, capacity를 가진다. 그래서 slice를 초기화 할 때, map, chanel처럼 객체를 생성해주기 위해 make함수를 쓰는 것이다. 참고로 그렇기 때문에 slice인스턴스의 주소를 배열의 주소와는 별개로 어딘가에 저장되어있다는 뜻이다.