# 패리티 비트
* **에러를 검출**하기 위해 추가하는 비트
* 통신용 아스키코드(7비트)와 함께 주로 사용

## 패리티 코드
### 홀수 패리티
* 해당 범위의 비트에 들어있는 1의 개수를 홀수로 만들어 주는 패리티 비트
* 즉, 디코딩시 비트의 1의 개수가 홀수개이면, 정상데이터인 것임.

### 짝수 패리티
* 해당 범위의 비트에 들어있는 1의 개수를 짝수로 만들어주는 패리티 비트
* 즉, 디코딩시 비트의 1의 개수가 짝수개이면, 정상데이터인 것임.(1의 개수가 0개인 것도 짝수로 취급)

#### 패리티 코드의 장단점
* 홀수 개의 오류를 검출함
* 짝수 개의 오류를 검출할 수 없음

e.g.) 
* 예를 들어 홀수 패리티 코드를 쓰는 데이터 8bit에 1/1/1/0/1/1/1/1 이라고 되어 있다고 하자
* 여기서 1/1/0/0/1/1/1/1으로 변조되었다면, 1의 개수가 6개임으로 변조되었다는 것을 알 수 있다.
* 그런데 만약, 1/1/0/0/0/1/1/1으로 변조가 2개 되었다면?
* 변조가 2bit가 되었음에도 1의 개수가 홀수개임으로 변조를 찾지 못한다.
* 짝수 패리티 코드고 마찬가지 임 

>> 병렬 패리티로 완화

# 병렬 패리티
* **에러를 검출**하기 위한 세로 중복 검사
* 패리티 비트가 포함된 8bit의 데이터를 세로 방향으로 1의 개수를 구해서 패리티 코드에 맞게 1을 넣고 빼는 패리티 코드
* 즉, 세로의 패리티 코드로 보면 됨

## 병렬 패리티의 장단점
* 기존의 8bit에서 변조가 짝수개일 때 변조를 찾지 못하는 상황을 해결함
* 하지만, 짝수 단위에서 변조가 깉은 세로열에서 발생한다면, 변조를 찾지 못함

e.g.)
* A라는 문자를 bit로 나타내면 1/0/0/0/0/0/1에 패리티 코드 1을 붙여서 홀수 패리티 만족하게 만듦(B와 C도 홀수 패리티로 만듦)
* A:1/0/0/0/0/0/1/1
* B:1/0/0/0/0/1/0/1
* C:1/0/0/0/0/1/1/0
* *:0/1/1/1/1/1/1/1 << 병렬 패리티(세로로 1의 개수를 세서 홀수개로 맞춰서 저장함)
* 여기서 A:1/0/1/1/0/0/1/1로 변조되면, 병렬 패리티가 홀수 패리티를 만족하지 않아 오류검출
* 그런데 만약
* A:1/0/1/1/0/0/1/1
* B:1/0/1/1/0/1/0/1 
* C:1/0/0/0/0/1/1/0
* *:0/1/1/1/1/1/1/1
* 이렇게 같은 세로열에서 짝수 개의 변조가 있다면, 병렬 패리티로는 오류를 찾을 수 없음

>> 해밍코드로 해결