# Design Pattern
>> 코드를 더 알아보기 쉽게 혹은 짜기 쉽게, 유지보수가 쉽게 하기 위해 설계 단게에서 사용되는 기술이다.

* 디자인 패턴을 배우고 나면, 코딩을 쉽게하기 위해 디자인 패턴을 활용하는 것이 아니라, 디자인 패턴을 적용시키기 위해 코딩을 하는 경우가 있다.
* 디자인 패턴을 배우는 이유가 코딩을 쉽게하는데 있는 만큼, 코딩을 할 때, 무조건 디자인 패턴을 적용시키기는게 아니라, 내가 설계할 때 사용할 수 있는 도구가 늘어났다는 관점으로 가야한다.
* 즉, 디자인 패턴을 적용시키지 않아도 혹은 적용시키면 안되는 프로그래밍은 디자인 패턴을 적용시키지 않는 것이 맞다는 소리다.

***
# SOLID
***
## Single Responsibility principles(단일 책임 원칙)
>> 하나의 객체는 하나의 책임을 갖는다
* 쉽게말해 객체의 이름에 맞는 역할만을 수행할 것을 요구한다는 것이다.

### Single Responsibility을 따르지 않는다면?
* 1객체=1책임의 원칙을 깬다면, 하나의 객체에 많은 기능을 수행하게 해야한다.
* 그렇게되면, 한 객체에 의존성이 높아지게된다.
* 의존성이 높아지면, 다른 객체에서 이 객체에 연관성이 높아져 많은 기능과 변수를 public으로 열어줘야한다.
* 그러면, 객체지향의 특성인 은닉화와 캡슐화에 위배되는 설계이다.

### Single Responsibility 적용하려면?
* 간단히 1객체=1책임을 따르면 된다.
* 예를 들어, 컴퓨터라는 객체가 있다고 하자
* 그러면 컴퓨터라는 상위 클래스를 만들고, cpu, memory, cache, disk.... 등의 하위클래스를 만들면 된다.
* 이렇게 되면, 컴퓨터라는 객체에 의존성이 감소한다. 이는 객체지향 설계에 가까워지는 것이다.
* 만약 ram의 기능을 수정하고 싶으면, ram class만 수정하고, cache의 기능을 수정하고 싶으면 cache class를 수정하면 되기 때문에, 한 객체에 많은 책임을 지게하지 않는다.
* 즉, 한 객체가 가지는 책임을 다른 객체에 분산하거나, 그 객체에 맞는 책임만을 주어야한다는 것이다.

### 핵심
>> 한 객체에 하나의 책임만을 부여 함으로써 객체끼리 의존성을 떨어뜨리고 유지보수하기 쉬워진다.

***
## Open Closed principles(개방 폐쇄 원칙)
>> 확장은 개방적으로, 수정은 폐쇄적으로 설계해야한다는 원칙이다.
* 하나의 기능을 두고, 확장할 때, 기능을 수정하는 것이 아니라 확장의 대상만 추가하는 것이다.

### Open Closed principles을 따르지 않는다면?
* 예를 들어, Animal이라는 클래스에 기능으로 동물의 울음소리를 내는 함수가 있다고 하자
* 이 함수는 Animal객체의 type이라는 멤버 변수의 값에 따라 울음소리를 다르게 낸다
* 함수 내부적으로는 if문으로 type이 cat이면 meow를 dog이면 bark를 출력하도록 설계되어있다.
* 이때, type이 cow인 경우를 추가하고 싶을 때, 함수를 반드시 수정해야한다.
* 지금의 예시는 하나의 기능만을 서술하고 있어 함수를 수정한다는게 적은 노동값을 가진다고 생각할 수 있다.
* 하지만, 기능을 가지는 함수가 1개가 아니라, 20개가 넘는 함수가 있다면, type이 cow를 추가할 때, 이 모든 함수를 type이 cow일때의 경우를 생각해서 수정해주어야한다.

### Open Closed principles를 적용하면?
* Animal클래스를 상위클래스로 구분하고 하위 클래스로 Cat과 Dog을 만든다.
* 울음소리를 내는 함수 hey를 Animal에 구현한다.
* 그리고 Cat과 Dog에 hey를 각 동물의 울음소리에 맞게 오버라이딩한다
* 이 때, hey를 호출하면 호출한 객체의 타입에 따라 울음소리가 나온다
* 여기서 cow를 추가하려면 hey의 기능을 고치는 것이 아닌, Cow라는 class만 정의 해주면 hey함수의 수정 없이 기능을 확장할 수 있다.
* 이 경우 cow를 추가하는 것을 open hey함수를 수정하지 않는 것이 closedd이다.

### 핵심
>> 새로운 객체에 대응하는 기능을 확장함에 있어 객체만 확장하면 기능을 수정할 필요없이 원하는 동작을 할 수 있다는 것이다.

***
### Liskov Substitution principle(리스코프 치환 원칙)
>> 부모클래스와 자식클래스가 있을 때, 자식클래스가 부모클래스로 치환될 때, 기능을 수행함에 문제가 없어야 한다는 것이다.
* 자식객체가 부모객체로 업캐스팅 되었을 때, 여전히 동작이 잘 되어야한다는 것이다.

### Liskov Substitution principle을 따르지 않는다면?
* 먼저 부모클래스와 자식클래스의 정의가 명확해야한다. 
* 예를 들어 Animal이라는 부모클래스에 Cat이라는 자식클래스가 있고, Animal클래스에  울음소리를 내는 hey함수가 있다.
* 이때, Fish가 Animal을 상속받는 자식클래스라면, Fish 객체를 Animal객체로 업캐스팅 한다면
* 울음소리가 정의되어 있지 않은 Fish객체는 hey함수를 사용할 수 없다.
* 따라서 자식객체가 부모객체로 완전히 대체되지 않는다면, 동작을 수행하는데 오류가 날 수 있다는 것이다.

### 핵심
>> 자식객체가 부모객체로 완전히 대체가능해야 한다.

***
## Interface segregation Principle(인터페이스 분리 원칙)
>> 인터페이스에 너무 많은 역할을 부여하지 말고 분할해서 관리하라는 원칙
* 여기서 인터페이스는 상위클래스로 해석하면 될 거 같다. 즉, 상위 클래스의 역할을 분할해서 여러개의 상위클래스로 관리하라는 뜻

### Interface segregation Principle을 따르지 않는다면?
* 예를 들어 상위클래스에 A,B 두가지의 역할을 하게 한다고 하자
* 이때, 하위 클래스에서는 A의 기능만 필요하지만, 어쩔 수 없이 A,B 기능 모두 상속 받는다
* 이 경우 필요없는 B의 기능까지 물려받고 정의해야하기 때문에 난감해진다.

### Interface segregation Principle를 적용하면?
* A,B를 한 클래스에 담는게 아니라, A기능만 가지는 클래스, B기능만 가지는 클래스로 분할한다.
* 그러면 A기능만 필요하면 A만 상속 받는게 가능해진다.
* 또한, A,B모두 필요한 경우 A,B클래스 모두 상속 받으면 된다.
* 따라서 상황에 따라 상속 받고 싶은 만큼만 받을 수 있다는 것이다.
* 상위 클래스의 유지보수 또한 쉬워질 것이다.

### 핵심
>> 상위클래스의 역할을 분할 함으로써, 필요없는 기능의 상속을 막고, 상위 클래스의 유지보수가 쉬워짐

## Dependency inversion Principle(의존관계 역전 원칙)
>> 추상화에 의존해야지, 구체화에 의존하면 안된다. 혹은 고수준 클래스가 저수준 클래스에 의존하면 안된다.
* 여기서 고수준과 저수준의 의미는 저수준 모듈은 고수준 모듈의 수행을 돕는 모듈이다.
* 의존관계 역전 원칙을 풀어 설명하면, 고수준 모듈이 저수준 모듈을 직접적으로 참조하는 것이 아니라, 중간에 추상화 모듈을 만들어서 기존의 관계가 고수준 >> 저수준 이었다면, 고수준 >> 추상화 << 저수준으로 바꿔 준다는 것이다.

### Dependency inversion Principle을 따르지 않는다면?
* 예를 들어 A클래스와 B클래스가 있고 이 두 클래스를 다른 클래스F에서 객체로 만들어서 기능을 구현한다고 하자.
* 이때, C클래스가 생기고 기능을 확장하려면 F클래스에서 C클래스에 대한 기능을 정의해주어야 한다.
* 이런 상황이 클래스가 만들어질 때 마다 일어난다면, 매우 번거러운 일이다.

### Dependency inversion Principle을 적용하면?
* A클래스와 B클래스의 상위 클래스로 X클래스를 만든다
* 그리고 이 X클래스를 F클래스에서 참조하는 것이다.
* F클래스에는 내부적으로 X클래스에 대한 기능 정의가 되어있다
* 이때, C클래스가 생기더라도 결국은 상위클래스인 X클래스에 묶여있기 때문에 F클래스의 수정없이 기능을 잘 수행한다
* 여기서 F클래스는 고수준모듈, X클래스는 추상화모듈, A,B클래스는 저수준모듈이다.

### 핵심
>> 고수준 모듈이 저수준 모듈에 의존하는 방식이 아닌, 중간에 추상화 모듈을 고수준, 저수준 모듈 둘 다 의존함으로써 코드의 확장성과 재사용성을 높이기 위함이다.